# 인덱스

## 선택도 (Selectivity)

데이터베이스에서 특정 컬럼의 고유 값의 비율
인덱스의 효율성을 평가하는 중요한 지표
선택도가 높을수록 인덱스가 쿼리 성능에 더 큰 이점을 제공

### 정의
- 고유 값 수(DISTINCT 값의 수) / 전체 행 수
- 선택도 값 범위: 0 < 선택도 ≤ 1
	-	1에 가까울수록: 모든 값이 고유하므로 선택도가 높습니다.
	-	0에 가까울수록: 중복된 값이 많아 선택도가 낮습니다.

### 선택도를 확인해야 하는 이유

-	인덱스 효율성 평가:
-	선택도가 높은 컬럼에 인덱스를 생성하면 검색 범위를 크게 줄일 수 있어 성능이 향상됩니다.
-	선택도가 낮은 컬럼에 인덱스를 생성하면 인덱스 오버헤드만 증가하고 성능 개선 효과는 미미합니다.
-	복합 인덱스 생성 시 컬럼 순서 결정:
-	선택도가 높은 컬럼을 인덱스의 선두 컬럼으로 배치하면 효율적인 검색이 가능합니다.


### 선택도 계산 방법

A. 전체 행 수 확인

먼저, 테이블의 전체 행 수를 알아야 합니다.

```sql
SELECT COUNT(*) AS total_rows FROM `TMG_MSG_GRP`;
```

B. 각 컬럼의 고유 값 수 확인

쿼리에 사용되는 각 컬럼의 **고유 값 수(DISTINCT 값의 수)**를 조회합니다.

예를 들어, MB_ID, MSG_DVS_CD, API_INSTC_ID, REG_DTT 컬럼에 대해 다음과 같이 조회합니다.

```sql
-- MB_ID 컬럼의 고유 값 수
SELECT COUNT(DISTINCT `MB_ID`) AS unique_mb_id FROM `TMG_MSG_GRP`;

-- REG_DTT 컬럼의 고유 값 수
SELECT COUNT(DISTINCT DATE(`REG_DTT`)) AS unique_reg_dtt_dates FROM `TMG_MSG_GRP`;
```

### 인덱스 컬럼 순서 결정

선택도가 높은 컬럼부터 인덱스에 포함하는 것이 좋습니다.

## 카디날리티 (Cardinality)

인덱스가 적용된 컬럼에서 고유한 값의 개수

-	높은 카디널리티: 컬럼에 저장된 값들이 대부분 고유하여 중복이 거의 없는 경우.
-	예: 주민등록번호, 이메일 주소 등.
-	낮은 카디널리티: 컬럼에 저장된 값들이 중복되어 고유 값의 수가 적은 경우.
-	예: 성별, 상태 코드 등.

### 카디널리티와 선택도의 관계

-	**선택도(Selectivity)**는 카디널리티를 기반으로 계산되며, **선택도 = 카디널리티 / 전체 행 수** 로 표현됩니다.
-	카디널리티가 높을수록 선택도가 높아지고, 이는 인덱스의 효율성을 높여줍니다.
-	선택도 값 범위: 0 < 선택도 ≤ 1
-	1에 가까울수록: 모든 값이 고유하므로 인덱스의 검색 효율이 높습니다.
-	0에 가까울수록: 중복된 값이 많아 인덱스의 효율성이 낮습니다.

### 카디널리티 값 확인 방법

MySQL에서 SHOW INDEX 명령을 사용하여 인덱스의 카디널리티 값을 확인할 수 있습니다.

```sql
SHOW INDEX FROM `TMG_MSG_GRP`;
```

이 명령은 해당 테이블의 인덱스 정보를 보여주며, 결과는 다음과 같은 컬럼을 포함합니다:

-	Table: 테이블 이름
-	Non_unique: 인덱스의 고유 여부 (0: 고유, 1: 중복 허용)
-	Key_name: 인덱스 이름
-	Seq_in_index: 인덱스 내에서 컬럼의 순서
-	Column_name: 인덱스에 포함된 컬럼 이름
-	Collation: 인덱스 정렬 순서
-	Cardinality: 인덱스의 카디널리티 값
-	Sub_part: 인덱싱된 문자열의 접두사 길이
-	Packed: 인덱스 키의 압축 여부
-	Null: 컬럼이 NULL 값을 허용하는지 여부
-	Index_type: 인덱스의 종류 (BTREE, FULLTEXT 등)
-	Comment: 추가 정보
-	Index_comment: 인덱스에 대한 주석

### 카디널리티 값 해석

-	Cardinality 컬럼은 해당 인덱스의 고유 값 수에 대한 근사치를 제공합니다.
-	MySQL 옵티마이저는 이 카디널리티 값을 활용하여 실행 계획을 수립합니다.
-	카디널리티 값이 높을수록 인덱스의 검색 효율이 높아집니다.


### 카디널리티를 활용한 인덱스 최적화

A. 인덱스 컬럼 순서 결정

-	카디널리티가 높은 컬럼을 선두 컬럼으로 배치합니다.
-	복합 인덱스의 경우, 카디널리티가 높은 컬럼부터 낮은 컬럼 순서로 배치하여 검색 효율을 높입니다.

B. 선택도 계산

-	선택도 = 카디널리티 / 전체 행 수
-	예를 들어, MB_ID의 카디널리티가 50,000이고 전체 행 수가 1,000,000이라면:

### 카디널리티 정보의 정확성 확보

-	카디널리티 값은 근사치이며, 테이블의 데이터 변경에 따라 달라질 수 있습니다.
-	정확한 카디널리티 값을 얻기 위해 통계 정보를 업데이트합니다.

```sql
ANALYZE TABLE `TMG_MSG_GRP`;
```

### 카디널리티와 데이터 분포 고려

-	카디널리티 값만으로는 충분하지 않을 수 있으며, 데이터 분포를 함께 고려해야 합니다.
-	예를 들어, 특정 값에 데이터가 집중되어 있으면, 카디널리티가 높아도 실제 검색 효율은 떨어질 수 있습니다.
-	데이터의 분포를 파악하기 위해 히스토그램이나 데이터 샘플링을 활용할 수 있습니다.


## 인덱스 컬럼 순서

**복합 인덱스(composite index)** 를 생성할 때 컬럼의 순서가 매우 중요

### 인덱스의 컬럼 순서의 중요성

A. 인덱스의 구조

-	단일 컬럼 인덱스: 하나의 컬럼에만 인덱스가 생성됩니다.
-	복합 인덱스: 두 개 이상의 컬럼으로 구성된 인덱스입니다. 컬럼들의 순서가 지정됩니다.

B. 컬럼 순서가 중요한 이유

-	인덱스는 **왼쪽에서 오른쪽으로 컬럼들을 순차적으로 사용**합니다.
-	인덱스의 선두 컬럼부터 조건에 사용되어야 인덱스가 효과적으로 활용됩니다.
-	**선두 컬럼이 조건에 포함되지 않으면, 후속 컬럼들은 인덱스에서 사용되지 않거나 제한적으로만 사용됨**

### 예시를 통한 이해

예시 상황

-	복합 인덱스: (A, B, C) 순서로 생성된 인덱스가 있습니다.
-	테이블에 대한 쿼리가 다음과 같이 있을 때 인덱스의 활용 여부를 살펴보겠습니다.

A. 선두 컬럼부터 조건에 사용되는 경우

1.	WHERE A = ?
-	인덱스 사용 가능
-	선두 컬럼 A를 조건에 사용하므로 인덱스가 효과적으로 활용됩니다.
2.	WHERE A = ? AND B = ?
-	인덱스 사용 가능
-	A와 B 모두 조건에 사용되므로 인덱스를 통해 검색 범위를 더욱 좁힐 수 있습니다.
3.	WHERE A = ? AND B = ? AND C = ?
-	인덱스 사용 가능
-	모든 컬럼이 조건에 사용되므로 인덱스의 효율이 극대화됩니다.

B. 선두 컬럼을 건너뛰는 경우

1.	WHERE B = ?
-	인덱스 사용 불가
-	선두 컬럼 A가 조건에 없으므로 인덱스가 활용되지 않습니다.
2.	WHERE A = ? AND C = ?
-	인덱스는 A 컬럼에 대해서만 사용
-	B 컬럼을 건너뛰고 C 컬럼을 조건에 사용하므로, C에 대한 인덱스 활용은 제한적입니다.
3.	WHERE C = ?
-	인덱스 사용 불가
-	선두 컬럼 A와 B가 조건에 없으므로 인덱스가 활용되지 않습니다.

### 인덱스 컬럼 순서 결정 시 고려 사항

A. 쿼리 패턴 분석

-	실제로 자주 사용되는 쿼리에서 어떤 컬럼들이 조건으로 사용되는지를 파악합니다.
-	선두 컬럼부터 조건에 자주 사용되는 컬럼 순서대로 인덱스를 생성합니다.

B. 선택도 고려

-	선택도가 높은 컬럼을 선두에 배치하면 검색 범위를 크게 줄일 수 있습니다.
-	하지만 쿼리에서 조건으로 사용되지 않는다면 인덱스의 효율성이 떨어집니다.
-	따라서 쿼리에서 자주 조건으로 사용되는 컬럼 중 선택도가 높은 순서대로 인덱스를 구성하는 것이 좋습니다.

### 쿼리와 인덱스의 컬럼 순서 매칭

```sql
SELECT COUNT(*)
FROM TMG_MSG_GRP
WHERE MB_ID = ?
  AND MSG_DVS_CD = ?
  AND API_INSTC_ID IS NULL
  AND REG_DTT >= ?
```

```sql
CREATE INDEX idx_tmg_msg_grp_opt ON TMG_MSG_GRP (
  MB_ID,
  MSG_DVS_CD,
  API_INSTC_ID,
  REG_DTT
);
```

### 각 접근법의 장단점

A. WHERE 절의 컬럼 순서대로 인덱스 구성

- 장점:
  -	**쿼리의 조건과 인덱스의 컬럼 순서가 일치**하므로, **옵티마이저가 인덱스를 효율적으로 사용하기 쉽다.**
  -	가독성이 좋고, 쿼리와 인덱스의 관계를 이해하기 용이합니다.
- 단점:
  -	컬럼의 선택도를 고려하지 않으므로, 검색 범위를 최적으로 줄이지 못할 수 있습니다.
  -	선택도가 낮은 컬럼이 선두에 위치하면, 인덱스의 효율이 떨어질 수 있습니다.

B. 컬럼의 선택도가 높은 순서대로 인덱스 구성

- 장점:
  -	**선택도가 높은 컬럼을 선두에 배치**하여, 검색 범위를 최대한 줄일 수 있습니다.
  -	인덱스의 효율성이 높아져 쿼리 성능이 향상될 수 있습니다.
- 단점:
  -	쿼리의 조건 순서와 인덱스 컬럼 순서가 일치하지 않을 경우, 옵티마이저가 인덱스를 효율적으로 사용하지 못할 수 있습니다.
  -	**쿼리 패턴에 따라 인덱스가 사용되지 않을 위험**이 있습니다.

### 인덱스 컬럼 순서 결정 시 고려해야 할 요소

A. 쿼리 패턴 분석

-	쿼리에서 자주 사용되는 조건과 컬럼의 조합을 파악해야 합니다.
- 조건의 종류:
  -	동등 조건(EQUALS): = 연산자를 사용한 조건.
  -	범위 조건(RANGE): >, <, BETWEEN, LIKE 등 범위 검색에 사용되는 조건.
- 인덱스의 활용 방식:
  -	**선두 컬럼부터 동등 조건에 사용된 컬럼들을 순서대로** 포함하는 것이 이상적입니다.
  -	그 다음으로 범위 조건에 사용되는 컬럼을 포함합니다.

B. 컬럼의 선택도(Selectivity)

-	선택도는 고유 값의 수 / 전체 행 수로 계산됩니다.
-	선택도가 높을수록 해당 컬럼이 검색 범위를 좁히는 데 효과적입니다.
-	**선택도가 높은 컬럼을 인덱스의 선두에 배치**하면, 쿼리 성능이 향상될 수 있습니다.

### 두 접근법의 결합과 최적화

실제로는 쿼리 패턴과 선택도를 모두 고려하여 인덱스의 컬럼 순서를 결정하는 것이 가장 효과적입니다.

A. 동등 조건의 컬럼을 선두에 배치

-	**동등 조건에 사용되는 컬럼들을 인덱스의 선두에 배치**합니다.
-	이때, 동등 조건 컬럼들 중 선택도가 높은 컬럼부터 배치하는 것이 좋습니다.

B. 범위 조건의 컬럼을 그 다음에 배치

-	동등 조건 컬럼 **다음에 범위 조건에 사용되는 컬럼을 배치**합니다.
-	범위 조건 이후의 컬럼은 인덱스에서 효율적으로 사용되지 않을 수 있으므로 주의해야 합니다.

### WHERE 절의 조건 순서를 무시해도 되는 이유

-	WHERE 절의 조건 순서는 실제로 옵티마이저가 실행할 때 변경될 수 있으며, 이는 성능 최적화를 위한 정상적인 동작입니다.
-	개발자는 WHERE 절의 조건 순서에 크게 신경 쓰지 않아도 되며, 대신 인덱스 설계와 쿼리 구조 최적화에 집중하는 것이 좋습니다.
-	옵티마이저는 조건의 순서, 인덱스의 존재 여부, 데이터의 분포 등을 고려하여 가장 효율적인 실행 계획을 자동으로 선택합니다.

1. WHERE 절의 조건 순서와 옵티마이저의 동작

A. WHERE 절의 조건 순서의 중요성

	-	SQL 표준에서는 WHERE 절의 조건 순서가 논리적 평가 순서를 결정하지 않습니다.
	-	즉, 사용자가 작성한 조건의 순서와 상관없이, 데이터베이스는 전체 조건을 평가하여 결과를 반환합니다.
	-	조건 순서 자체는 결과에 영향을 주지 않으며, 옵티마이저는 조건 순서에 구애받지 않고 최적의 실행 계획을 수립합니다.

B. 옵티마이저의 조건 재배열

	-	MySQL 옵티마이저는 WHERE 절의 조건을 분석하여 실행 계획을 최적화합니다.
	-	이를 위해 조건의 순서를 재배열하거나, 조건을 결합하거나 분해할 수 있습니다.
	-	조건의 선택도, 인덱스의 존재 여부, 연산 비용 등을 고려하여 가장 효율적인 평가 순서를 결정합니다.

2. 옵티마이저가 조건을 재배열하는 이유

A. 성능 최적화

	-	선택도가 높은 조건을 먼저 평가하면, 불필요한 레코드의 수를 줄일 수 있어 전체적인 쿼리 성능이 향상됩니다.
	-	옵티마이저는 조건의 비용을 추정하여, 비용이 낮고 필터링 효과가 높은 조건을 우선적으로 평가합니다.

B. 인덱스 활용 극대화

	-	인덱스가 있는 컬럼의 조건을 우선적으로 사용하여 검색 범위를 좁힐 수 있습니다.
	-	옵티마이저는 사용 가능한 인덱스를 확인하고, 인덱스 스캔을 통해 효율적으로 데이터를 검색합니다.

C. 조건 결합 및 분해

	-	논리적으로 동일한 조건이라도, 옵티마이저는 더 효율적인 형태로 조건을 변환할 수 있습니다.
	-	예를 들어, OR 연산자를 UNION으로 변환하거나, 복잡한 조건을 단순화할 수 있습니다.

3. 개발자가 알아야 할 사항

A. WHERE 절 조건 순서의 영향

	-	WHERE 절의 조건 순서는 결과에 영향을 미치지 않으므로, 가독성과 이해하기 쉬운 순서로 작성하면 됩니다.
	-	하지만 조건 순서가 쿼리 성능에 직접적인 영향을 미치지 않으므로, 성능 최적화를 위해 인덱스 설계와 쿼리 구조에 집중하는 것이 좋습니다.

B. 인덱스 설계의 중요성

	-	옵티마이저가 인덱스를 효과적으로 활용할 수 있도록, 적절한 인덱스 설계가 필요합니다.
	-	복합 인덱스의 컬럼 순서는 옵티마이저의 동작에 직접적인 영향을 미치므로, 쿼리 패턴과 선택도를 고려하여 설계해야 합니다.

C. 쿼리 최적화

	-	불필요한 서브쿼리, 복잡한 조인, 비효율적인 연산자 사용을 피하고, 단순하고 효율적인 쿼리 구조를 작성해야 합니다.
	-	EXPLAIN 명령어를 사용하여 실행 계획을 확인하고, 옵티마이저가 쿼리를 어떻게 처리하는지 이해하는 것이 중요합니다.


### 복합 인덱스 생성 시 주의 사항

A. 너무 많은 컬럼 포함 지양

-	인덱스에 **너무 많은 컬럼을 포함하면 인덱스 크기가 커져서 오버헤드가 증가**합니다.
-	필요한 최소한의 컬럼만 포함하여 인덱스를 생성합니다.

B. 컬럼 순서의 균형 잡기

-	선택도와 쿼리 패턴을 모두 고려하여 컬럼 순서를 결정합니다.
-	선택도가 높지만 쿼리에서 자주 사용되지 않는 컬럼을 선두에 배치하면 인덱스 활용도가 떨어질 수 있습니다.


## 결론 

1.	동등 조건(EQUALS) 컬럼들을 인덱스의 선두에 배치합니다.
2.	동등 조건 컬럼들 중에서는 선택도가 높은 컬럼부터 순서대로 배치합니다.
3.	그 다음으로 범위 조건(RANGE) 컬럼들을 배치합니다.
4.	범위 조건 컬럼들 중에서도 선택도가 높은 컬럼부터 순서대로 배치합니다.

1. 동등 조건 컬럼을 선두에 배치하는 이유

	-	인덱스는 선두 컬럼부터 순차적으로 조건을 적용합니다.
	-	동등 조건은 특정 값을 정확히 일치시키므로, 검색 범위를 크게 줄일 수 있습니다.
	-	따라서, 동등 조건 컬럼들을 먼저 배치하여 검색 범위를 최대한 좁히는 것이 효율적입니다.

2. 같은 조건 타입 내에서 선택도가 높은 컬럼을 앞에 배치하는 이유

	-	선택도가 높은 컬럼은 고유 값의 수가 많아, 해당 조건을 적용했을 때 검색 범위를 크게 줄여줍니다.
	-	선택도가 높은 컬럼부터 조건을 적용하면, 불필요한 데이터 접근을 최소화할 수 있습니다.
	-	이는 인덱스 스캔 범위를 줄여 쿼리 성능을 향상시킵니다.

3. 범위 조건 컬럼을 그 다음에 배치하는 이유

	-	범위 조건은 특정 범위 내의 값을 검색하므로, 동등 조건에 비해 검색 범위를 덜 줄여줍니다.
	-	또한, 인덱스에서 범위 조건 이후의 컬럼들은 효율적으로 사용되지 않을 수 있습니다.
	-	따라서, 범위 조건 컬럼들은 동등 조건 컬럼들 다음에 배치하여 인덱스의 효율을 높입니다.


## WHERE 절에 사용된 컬럼들이 각각 단일 컬럼 인덱스로 생성되어 있을 때

### 단일 vs 복합 컬럼 인덱스

A. 인덱스 사용 방식

-	MySQL 옵티마이저는 **일반적으로 하나의 테이블에서 하나의 인덱스만 사용**할 수 있습니다.
-	하지만 **인덱스 머지(Index Merge)** 라는 기능을 통해 **여러 개의 단일 컬럼 인덱스를 조합하여 사용**할 수 있습니다.
- 인덱스 머지 전략에는 다음과 같은 유형이 있습니다:
  - UNION: 여러 인덱스의 결과를 합집합으로 병합.
  -	INTERSECTION: 여러 인덱스의 결과를 교집합으로 병합.
  -	UNION + INTERSECTION: 위 두 가지를 조합.

B. 인덱스 머지의 한계

-	인덱스 머지 전략은 **항상 효율적이지 않을 수 있습니다.**
-	**복합 인덱스보다 성능이 떨어지는 경우**가 많습니다.
-	옵티마이저는 통계 정보와 비용 기반 분석을 통해 인덱스 머지를 사용할지 결정합니다.
-	인덱스 머지를 사용하지 않고 하나의 인덱스만 선택하거나, 전체 테이블 스캔을 할 수도 있습니다.

### 단일 컬럼 인덱스의 효과

A. 인덱스 선택 과정

-	옵티마이저는 **가장 효율적이라고 판단되는 인덱스 하나를 선택**하여 사용합니다.
-	이 경우, 조건절에서 선택도가 가장 높은 컬럼의 인덱스를 사용할 가능성이 높습니다.
-	나머지 조건들은 인덱스 필터링 후의 레코드에 대해 추가적인 필터링으로 처리됩니다.

B. 실행 계획의 예시

-	EXPLAIN을 통해 실행 계획을 확인하면, key 컬럼에 사용된 인덱스가 표시됩니다.
-	Extra 컬럼에 Using where 또는 Using index condition이 나타나면 나머지 조건은 인덱스 사용 후 추가로 필터링됩니다.

### 복합 인덱스와의 비교

A. 복합 인덱스의 장점

-	복합 인덱스는 **인덱스의 컬럼 순서대로 여러 조건을 효율적으로 처리**할 수 있습니다.
-	쿼리에서 사용되는 모든 컬럼을 포함한 복합 인덱스를 사용하면, **인덱스 레인지 스캔(Index Range Scan)** 을 통해 검색 범위를 크게 줄일 수 있습니다.
-	쿼리 성능이 단일 컬럼 인덱스에 비해 상당히 향상될 수 있습니다.

B. 인덱스 머지와의 성능 비교

-	인덱스 머지 전략은 추가적인 병합 작업으로 인해 오버헤드가 발생할 수 있습니다.
-	복합 인덱스는 하나의 인덱스에서 필요한 데이터를 모두 처리하므로 더 효율적입니다.
-	따라서, 자주 사용되는 쿼리에 맞춰 복합 인덱스를 생성하는 것이 성능 향상에 도움이 됩니다.

### 권장 사항

A. 복합 인덱스 생성 고려

-	쿼리에서 자주 결합되어 사용되는 컬럼들에 대해 복합 인덱스를 생성하는 것이 좋습니다.
-	앞서 언급한 쿼리의 경우, 다음과 같은 복합 인덱스를 생성할 수 있습니다:
- 컬럼 순서는 쿼리의 WHERE 절에서 사용되는 컬럼 순서와 일치시키는 것이 좋습니다.

B. 인덱스 컬럼 순서 최적화

-	선택도가 높은 컬럼을 앞에 배치하여 검색 효율을 높일 수 있습니다.
-	그러나 쿼리에서의 사용 빈도와 조건 적용 순서도 고려해야 합니다.

C. 기존 단일 컬럼 인덱스 관리

-	복합 인덱스를 생성한 후, 기존의 단일 컬럼 인덱스 중 불필요한 것들은 제거하여 인덱스 유지 비용을 줄입니다.
-	하지만, 다른 쿼리에서 단일 컬럼 인덱스를 사용하고 있다면 삭제에 주의해야 합니다.

5. 추가적인 고려 사항

A. 인덱스 머지 사용 여부 확인

-	EXPLAIN 명령을 통해 실행 계획에서 **“Using index merge”** 가 나타나는지 확인합니다.
-	인덱스 머지가 사용되더라도 성능이 만족스럽지 않다면 복합 인덱스를 고려합니다.

B. 옵티마이저 힌트 사용

-	특정 인덱스의 사용을 강제하기 위해 옵티마이저 힌트를 사용할 수 있습니다.
-	그러나 옵티마이저 힌트는 유지보수성과 호환성 측면에서 신중히 사용해야 합니다.

### 옵티마이저가 복합 인덱스 대신 단일 인덱스를 선택하게 된 케이스

복합 인덱스의 비효율성 추정

1.	복합 인덱스의 선두 컬럼인 MB_ID와 MSG_DVS_CD의 선택도가 낮을 수 있음
2.	선두 컬럼의 낮은 선택도로 인해 복합 인덱스의 효율 저하
-	옵티마이저는 선두 컬럼의 선택도가 낮으면 해당 인덱스를 사용하더라도 검색 범위를 크게 줄이지 못한다고 판단합니다.
-	따라서 전체적인 비용을 고려하여 단일 인덱스를 선택할 수 있습니다.

## 출처

https://velog.io/@hwaya2828/Database-Index

https://spiderwebcoding.tistory.com/6