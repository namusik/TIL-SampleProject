# Java Memory

## 자바 논리적인 메모리 구조
자바 애플리케이션이 실행될 때, 자바 바이트코드는 JVM 상에서 동작하게 됩니다. JVM은 크게 아래와 같은 메모리 영역을 가집니다.

1.	메서드 영역(Method Area)
2.	힙(Heap)
3.	스택(Stack)
4.	PC 레지스터(Program Counter Register)
5.	네이티브 메서드 스택(Native Method Stack)

자바 객체가 실제로 생성되고 관리되는 핵심 영역은 주로 “힙”이며, 스레드별로 할당되는 스택도 중요한 역할

### 메서드 영역(Method Area)
-	**클래스와 인터페이스의 메타정보**(클래스 이름, 부모 클래스 이름, 메서드, 변수 정보 등)와 함께, 런타임 상수 풀(Runtime Constant Pool) 등의 정보를 저장하는 영역입니다.
- 특징
  - JVM이 **구동될 때 로드되는** 클래스, 메서드, 인터페이스 등의 정보를 저장
- 실제 저장되는 공간
	- 자바 7까지는 메서드 영역이 `PermGen`(Permanent Generation)이라는 JVM 힙의 일부 영역에 저장됐음.
  	-  PermGen은 고정된 크기로 할당되어 때때로 메모리 부족 문제를 일으켰다.
  - **자바 8부터**는 JVM 힙 외부의 **Metaspace**라는 `네이티브 메모리 영역`에 저장
    - **네이티브 메모리(시스템 메모리)** : JVM 힙 외부에서 운영체제가 직접 관리하는 메모리
    - 메타스페이스는 네이티브 메모리의 한 부분
    - 필요에 따라 동적으로 크기가 조절됨.
    - GC(가비지 컬렉션) 정책도 JVM 힙과 다르게 적용되므로, 클래스 메타데이터 관리에 유연성이 생김.
    - -XX:MaxMetaspaceSize로 제한 가능
  - 클래스 로더에 의해 메서드 영역에 로드된 클래스들은 적절한 시점에 JVM이 언로드(unload)할 수 있습니다.

이 중에서 자바 객체가 실제로 생성되고 관리되는 핵심 영역은 주로 “힙”이며, 스레드별로 할당되는 스택도 중요한 역할을 합니다.

### 힙(Heap)
-	정의
new 키워드 등을 통해 동적으로 생성되는 객체와 배열이 저장되는 공간입니다. 애플리케이션에서 생성되는 대부분의 객체가 이 영역에 위치합니다.
-	특징
-	JVM 내부에서 가장 큰 메모리 공간이며, 가비지 컬렉터(GC)가 동작하는 주요 대상입니다.
-	모든 스레드가 공유하는 메모리 영역입니다.
-	자바 8 기준으로 기본 구조는 Young Generation과 Old Generation으로 나뉩니다.
-	Young Generation(Young 영역)
새로운 객체가 주로 생성되는 영역입니다. Young 영역은 다시 아래 3개의 영역으로 구성됩니다.
-	Eden: 새로 생성된 객체가 할당되는 공간
-	Survivor 0 (S0) / Survivor 1 (S1): Eden에서 살아남은 객체가 이동하는 공간
-	Old Generation(Old 영역)
Young 영역에서 여러 번의 GC(Minor GC)를 거치면서 살아남은 객체가 옮겨지는 영역입니다.
-	메모리 부족
힙 영역에 더 이상 객체를 생성할 수 없을 정도로 메모리가 부족해지면, java.lang.OutOfMemoryError: Java heap space 에러가 발생합니다.

#### JVM 힙 메모리 할당과 해제의 특징

JVM의 힙 메모리 관리 방식은 기본적으로 다음과 같은 특징이 있습니다:
	-	힙 메모리 확장:
	-	애플리케이션이 메모리를 더 필요로 하면, JVM은 -XX:MaxRAMPercentage로 지정된 최대 힙 크기(컨테이너 메모리의 75%)까지 힙 메모리를 확장합니다.
	-	이 과정에서 힙 메모리가 한 번 확장되면, 가비지 컬렉션(GC)으로 메모리를 회수하더라도 JVM은 기본적으로 힙 메모리를 줄이지 않고 유지합니다.
	-	힙 메모리 축소:
	-	JVM은 메모리를 반환하지 않는 전략을 채택하는 경우가 많습니다. 즉, 힙 메모리 사용량이 줄어들더라도 운영체제(OS)로 힙 메모리를 반환하지 않습니다. 이는 JVM이 다시 메모리를 요청하는 오버헤드를 줄이기 위해서입니다.

결과:

한 번 힙 메모리가 최대 크기로 확장되면, 이후 애플리케이션의 메모리 사용량이 줄어들더라도 컨테이너에서 보고되는 메모리 사용량은 줄어들지 않을 수 있습니다.


### 스택(Stack)
	-	정의
각 스레드(Thread) 마다 런타임 스택(Run-time Stack) 이 따로 할당되며, 스레드가 시작될 때 생성되고 스레드가 종료되면 스택도 함께 사라집니다.
	-	특징
	-	메서드 호출 시마다 스택 프레임(Stack Frame, 또는 Activation Record)이 생성되어 파라미터, 지역 변수, 리턴 주소 등을 저장합니다.
	-	메서드가 종료되면 해당 스택 프레임은 스택에서 제거(pop)됩니다.
	-	스택 프레임 안에는 ‘기본 타입’(int, double 등) 혹은 객체 참조(Reference) 등이 저장됩니다. 실제 객체의 데이터는 힙에 존재하므로, 스택에는 참조값만 들어있는 경우가 많습니다.
	-	스택이 꽉 차면 java.lang.StackOverflowError 가 발생할 수 있습니다.

### PC 레지스터(Program Counter Register)
	-	각 스레드마다 하나씩 존재하는 레지스터입니다.
	-	현재 수행 중인 JVM 명령(바이트코드)의 주소를 가리킵니다.

### 네이티브 메서드 스택(Native Method Stack)
	-	자바 코드가 아닌 네이티브 코드(C, C++ 등) 호출 시에 사용되는 스택입니다.
	-	네이티브 메서드를 실행하기 위한 스택 프레임을 저장합니다.

## 가비지 컬렉션(Garbage Collection)

자바의 가장 큰 특징 중 하나가 바로 가비지 컬렉터(GC) 입니다. 프로그래머가 직접 메모리를 해제해주지 않아도, JVM에 의해서 사용되지 않는 객체를 자동으로 메모리에서 정리해 줍니다.

2.1 가비지 컬렉션의 기본 원리
	-	Reachability(도달성) 분석
GC는 ‘루트(Root) 객체’에서 시작하여 객체를 따라가며 참조가 도달 가능한 객체(Reachable Object)인지 판별합니다.
	-	도달 가능한 객체: 여전히 참조되고 있으므로 제거되지 않음
	-	도달 불가능한 객체: 더 이상 참조되지 않으므로 GC의 대상
	-	JVM 루트(Root) 예:
	-	스택(Stack) 내 지역 변수
	-	클래스 변수(static)
	-	레지스터(PC 레지스터) 등

2.2 주요 가비지 컬렉션 알고리즘
	-	Serial GC
단일 스레드로 동작하는 GC입니다. 작은 애플리케이션에서 주로 사용됩니다.
	-	Parallel GC
여러 스레드를 이용해서 동시에 Young 영역을 수집하는 방식입니다. Throughput을 높이기 위해 활용될 수 있습니다.
	-	CMS(Concurrent Mark Sweep) GC (자바 8에서 deprecated)
Old 영역을 병렬로 마크 및 스위핑하는 방식이지만, 일부 단점을 보완하기 위해 G1 GC로 대체되는 추세입니다.
	-	G1( Garbage First) GC (자바 9부터 기본 GC)
힙을 여러 개의 작은 Region으로 나누어, 가비지가 많은 영역부터 우선적으로 수집하는 방식입니다. CMS의 단점을 개선한 최신 알고리즘 중 하나입니다.
	-	ZGC, Shenandoah GC 등
대규모 힙 환경에서의 GC 정지 시간을 더 줄이기 위해 도입된 고급 GC 방식입니다.

## 객체 생성과 메모리 할당 과정
1.	new 키워드를 통해 객체를 생성하면, 먼저 Eden 영역에 공간이 할당됩니다.
2.	Eden에 할당된 객체 중에서 불필요해진 객체가 있으면 Minor GC가 수행되어 제거됩니다.
3.	Eden 영역에서 살아남은 객체들은 Survivor 영역(S0, S1)으로 이동합니다.
4.	Survivor 영역을 거치면서 여러 번 GC 이후에도 살아남은 객체들은 Old 영역으로 이동합니다.
5.	Old 영역에 더 이상 공간이 부족하거나, Old 영역의 GC가 필요하다고 판단되면 **Major GC (Full GC)**가 수행될 수 있습니다.

## 메모리 튜닝과 모니터링
	-	JVM 옵션
	-	-Xmx, -Xms: 힙 메모리의 최대/초기 크기를 설정합니다.
	-	-Xmn: Young 영역 크기를 설정합니다(자바 8 기준).
	-	-XX:MetaspaceSize, -XX:MaxMetaspaceSize: 메타스페이스 크기를 설정합니다(자바 8 이상).
	-	-XX:+UseG1GC: G1 GC 사용 설정, 그 외 다른 GC 사용 옵션 등.
	-	모니터링 도구
	-	jconsole, jvisualvm, jmap, jstat, jstack 등 다양한 툴을 통해 JVM 메모리 사용량, GC 동작 상태 등을 확인할 수 있습니다.
	-	운영 중인 서버에서는 APM(Application Performance Management) 도구 (예: New Relic, Datadog, Elastic APM 등)를 활용하여 실시간 모니터링을 진행하기도 합니다.


- JVM(Java Virtual Machine) 내에서 힙 메모리를 사용하여 객체를 생성하고 관리
- JVM은 힙 메모리를 동적으로 할당하지만, 다음과 같은 특성 때문에 메모리 사용량이 즉시 감소하지 않을 수 있다.
- 힙 메모리 할당:  
  - JVM은 필요한 만큼 힙 메모리를 할당하며, 한 번 할당된 메모리는 기본적으로 프로세스가 종료될 때까지 유지됩니다. 즉, 대량의 요청을 처리하면서 JVM이 힙을 확장했다면, 요청이 감소하더라도 JVM은 그 힙 메모리를 다시 줄이지 않습니다.
- 가비지 컬렉션(Garbage Collection): 사용하지 않는 객체는 가비지 컬렉션을 통해 해제되지만, 힙 메모리가 OS로 반환되는 시점은 JVM의 가비지 컬렉션 전략과 JVM 옵션에 따라 다릅니다.


## memory swap
- 물리 메모리(RAM)가 부족할 때, 사용하지 않는 메모리 페이지(프로세스에 의해 잠시 참조되지 않는 부분)를 디스크로 옮기는 기술
- Linux 시스템에서 swap 파티션(또는 swap 파일)이 활성화되어 있다면, 커널은 물리 메모리 압박이 올 때 자동으로 swap 영역을 사용해 메모리를 확보
- 보통 서버 환경에서 swap이 자주 발생하면 디스크 I/O가 증가하여 성능이 크게 저하될 수 있으므로, 모니터링해야 할 중요한 항목

## memeory failure
- 메모리를 더 이상 할당할 수 없어서 실패한 횟수
- 시스템 혹은 cgroup에서 메모리 할당이 더 이상 불가능할 때 발생하는 이벤트
- 서버 전체의 물리 메모리(RAM)와 스왑(Swap) 공간이 모두 부족할 때 발생
- 물리 메모리 부족:
  - 서버의 RAM이 이미 다른 프로세스에 의해 사용 중이며, 새로 요청된 메모리를 할당할 공간이 없는 상태
- 스왑(Swap) 부족:
  - 메모리가 부족한 상황에서 OS가 데이터를 디스크의 스왑 공간으로 이동시키는 메커니즘을 사용할 수 있지만, 스왑 공간도 가득 차면 더 이상 메모리를 할당할 수 없다.

## 관련 JVM 옵션

-XX:InitialRAMPercentage=75.0
컨테이너가 부여받은 메모리의 75%를 초기 힙 크기로 사용하겠다는 의미

-XX:MaxRAMPercentage=75.0
컨테이너 전체 메모리의 75%를 힙의 최대 크기로 설정하겠다는 의미입니다.

## memory 확인하기 

```sh
grep -i pss | awk '{sum+=$2} END {print sum}'
```
- PSS(Proportional Set Size)
  - 프로세스가 사용하는 메모리 중 공유 메모리를 포함한 비율에 따라 계산된 크기
- Java 프로세스가 실제로 사용하는 힙 메모리 외에도 스레드 스택, 메타스페이스, 네이티브 메모리, 공유 라이브러리 메모리 등을 포함한 전체 메모리 사용량에 대한 값을 제공


```sh
ls /proc/1/task | wc -l
```
- 스레드 수 확인