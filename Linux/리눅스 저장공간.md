# linux 저장 공간 

## 디스크 동작 철학
### 파일과 이름의 분리

- 리눅스에서는 파일의 '이름'과 '실제 데이터(알맹이)'가 별도로 관리됨.
  - 알맹이 (Inode): 파일의 실제 데이터와 소유자, 권한 등 모든 정보가 담겨있는 본체
  - 이름표 (Dentry): 우리가 ls로 보는 파일 이름. 이 이름표는 특정 알맹이(Inode)를 가리키는 포인터 역할
- 하나의 알맹이에 여러 개의 이름표를 붙일 수도 있다. (하드 링크).

### rm 명령어의 실제 동작
- 우리가 rm -f 명령어를 사용하면, 파일의 '알맹이'를 직접 지우는 것이 아니라 '이름표'를 떼어내는 동작을 한다.
- 운영체제는 해당 파일의 알맹이(Inode)를 더 이상 가리키는 이름표가 없고, 그 알맹이를 사용 중인 프로세스도 없을 때, 비로소 "아무도 쓰지 않으니 이제 버려도 되겠다"고 판단하여 디스크 공간을 회수

### 장점이자 단점

- 장점 (안정성): 
  - 어떤 프로세스가 파일을 열심히 사용하고 있는데 다른 사용자가 그 파일을 rm으로 지워도, 실행 중인 프로세스는 아무 문제 없이 작업을 계속할 수 있습니다. 시스템이 매우 안정적으로 동작하게 됩니다.
- 단점 (사용자의 오해): 
  - 하지만 사용자는 파일을 지웠다고 생각하는데 디스크 용량은 줄어들지 않는, 지금 겪고 계신 현상이 발생. 로그 파일처럼 장시간 열려있는 파일을 올바른 방법(프로세스 재시작 또는 truncate)으로 처리하지 않으면 이런 문제가 생깁니다.

## /proc

- 리눅스 시스템의 특별한 디렉토리로, **실제 디스크에 존재하는 '진짜' 파일 시스템이 아니다.**
- 대신, 커널(Kernel)이 메모리에서 관리하는 시스템의 다양한 정보와 프로세스 상태를 파일 형태로 보여주는 **'가상' 파일 시스템(Virtual Filesystem)**
- 자동차의 계기판 예시
  - 계기판은 엔진이나 연료 탱크 그 자체가 아니지만, 현재 엔진의 RPM이나 남은 연료량 같은 실시간 정보를 보여준다.
  - 마찬가지로 /proc은 커널 그 자체가 아니지만, 현재 실행 중인 프로세스 목록, CPU 정보(cat /proc/cpuinfo), 메모리 상태(cat /proc/meminfo) 등 커널이 알고 있는 실시간 정보를 파일처럼 보여주는 통로입
- 이 디렉토리의 파일들은 우리가 접근할 때마다 커널이 즉석에서 정보를 만들어 보여주며, 디스크 공간을 차지하지 않는다.


## 명령어

```sh
[ec2-user@ip-10-0-137-112 log]$ df -h
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        3.9G     0  3.9G   0% /dev
tmpfs           3.9G     0  3.9G   0% /dev/shm
tmpfs           3.9G  395M  3.5G  11% /run
tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup
/dev/nvme0n1p1  8.0G  8.0G   20K 100% /
/dev/nvme1n1    1.0T   27G  998G   3% /data
tmpfs           785M     0  785M   0% /run/user/1000
tmpfs           785M     0  785M   0% /run/user/0

sudo du -sh * | sort -hr
```


### /dev/nvme0n1p1
-	**/dev/nvme0n1p1**는 EC2 인스턴스에 연결된 첫 번째 NVMe(EBS) 볼륨입니다.
-	nvme0n1은 NVMe 프로토콜을 사용하는 첫 번째 블록 장치를 의미하고, 그 뒤의 p1은 이 디스크에서 첫 번째 파티션을 나타냅니다.
-	보통 이 파티션은 루트 파일 시스템(/)으로 마운트됩니다. 즉, 운영 체제와 중요한 시스템 파일들이 이 파티션에 저장됩니다.
-	이 파티션이 100%로 꽉 차면 시스템 성능이나 안정성에 문제가 발생할 수 있습니다.
- 로그 파일 정리
  - 주로 /var/log 디렉토리에 있는 로그들 정리
- 임시 파일 삭제
  - 


### /dev/nvme1n1
-	**/dev/nvme1n1**은 EC2 인스턴스에 연결된 두 번째 NVMe(EBS) 볼륨입니다.
-	nvme1n1은 두 번째 NVMe 프로토콜 블록 장치를 의미하며, 여기에는 별도의 파일 시스템이 있을 수 있습니다. 예를 들어, 데이터를 저장하는 /data와 같은 디렉토리가 이 파티션에 마운트될 수 있습니다.
-	이 볼륨은 용량이 크고 사용량이 적어 데이터를 저장하는 용도로 많이 사용됩니다.


### 용량 확인

```sh
du -h --max-depth=1 | sort -hr
```
- du: 디스크 사용량을 보여주는 명령어
- -h: 용량을 사람이 읽기 쉬운(Human-readable) 단위인 K(킬로바이트), M(메가바이트), G(기가바이트)로 보여줌
- --max-depth=1: 현재 위치를 기준으로 최대 1단계 깊이의 디렉토리까지만 용량을 보여준다. 이 옵션이 없으면 모든 하위 디렉토리의 용량을 전부 보여주어 결과가 너무 복잡
- sort: 입력된 텍스트를 정렬하는 명령어
- -h: du -h로 출력된 K, M, G 같은 단위를 숫자로 인식하여(Human-numeric sort) 크기 순서대로 올바르게 정렬
- -r: 역순(Reverse)으로 정렬하여, 용량이 가장 큰 항목이 맨 위로 오도록

```sh
ls -lhrS
```
- 하위 디렉토리는 제외하고 바로 아래에 있는 파일들의 용량만 보고 싶을 때
- ls -l: 파일을 자세한 목록 형태로 보여줍니다.
- -h: 파일 크기를 사람이 읽기 쉬운 단위(G, M, K)로 보여줍니다.
- -r: 정렬 순서를 반대로 (내림차순) 합니다.
- -S: 파일을 크기순으로 정렬합니다.

### 일반적인 파일 삭제 (프로세스가 사용하지 않는 파일)

```sh
# 기본 삭제
rm [파일명]

# 묻지 않고 강제 삭제
rm -f [파일명]
```

### 로그 파일 등 실행 중인 프로세스가 사용하는 파일 삭제
- 가장 권장하는 방법: logrotate 유틸리티 사용
  - 리눅스의 거의 모든 배포판에 포함된 로그 관리 전문 유틸리티
  - 설정 파일에 규칙(copytruncate 등)만 지정해두면, 삭제, 압축, 보관 주기 관리까지 알아서 가장 안전한 방식으로 처리해 줌. 
  - 직접 스크립트를 짜는 것보다 훨씬 안정적이고 강력하게 권장되는 표준 방식
- logrotate를 쓸 수 없는 상황이라면 다음 순서로 처리하는 것이 좋다.
  - 프로세스 재시작이 가능한 경우 (Best)
    - 파일을 rm으로 삭제한 뒤, 즉시 해당 파일을 사용하던 프로세스를 재시작. 
    - 프로세스가 재시작되면서 기존에 붙잡고 있던 (deleted) 파일과의 연결을 끊고 디스크 공간이 완전히 회수됨.
  - 프로세스 재시작이 불가능한 경우 (Workaround)
    - 파일을 삭제하는 대신 내용만 비운다.
```sh
truncate -s 0 [파일명]
```
- 이렇게 하면 프로세스를 중단시키지 않고도 디스크 공간을 즉시 확보가능


### rm -f로 파일을 삭제해도 용량이 줄지 않은 케이스

- 어떤 프로세스가 그 파일을 사용하고 있었기 때문
- 리눅스(유닉스) 시스템에서는 rm 명령어로 파일을 삭제하면 파일의 이름만 지워진다.
  - 만약 어떤 프로세스가 그 파일을 열어서 사용 중(로그를 기록하는 등)이라면, 운영체제는 그 프로세스가 "이제 이 파일을 다 썼다"고 연결을 끊기 전까지는 실제 데이터가 저장된 디스크 공간을 해제하지 않는다.
- 결과적으로 겉보기에는 파일이 지워졌지만, 디스크 용량은 그대로 차지하는 '좀비 파일' 상태가 된 것
- 왜 프로세스는 파일이 삭제됐는지 모르는가?
  - 프로세스는 자신이 연 파일의 이름이 바뀌거나 삭제된 것을 스스로 알지 못한다.
  - 작가는 노트를 펼치고 글을 쓰기 시작합니다. (프로세스가 파일을 열고 사용 시작)
  - 옆에서 다른 사람(rm 명령어)이 그 노트를 쓰레기통에 버립니다.
  - 하지만 글쓰기에 집중하고 있는 작가는 그 사실을 모릅니다. 작가는 여전히 자신의 손에 펜과 노트가 있다고 생각하고 허공에 계속 글을 씁니다. (프로세스는 이미 삭제된 파일에 계속 데이터를 쓰려고 시도)


```sh
sudo lsof | grep deleted | sort -k 7 -n
```
- '좀비 파일'들의 목록을 보여주는 명령어
- sudo lsof: 시스템에서 현재 열려있는 모든 파일의 목록을 보여주는 명령어
- grep deleted: 그 목록 중에서 (deleted) 라고 표시된, 즉 파일 이름은 삭제되었지만 프로세스가 여전히 붙잡고 있어 디스크 공간은 차지하고 있는 파일들만 골라서 보여줌


#### 해결방법

- /proc를 이용해 공간을 회수하는 원리
  - 이 방법의 핵심은 /proc 디렉토리 안에 있는 각 프로세스의 파일 디스크립터(FD) 정보
- 문제 상황: 
  - 특정 프로세스가 특정 로그 파일을 열어서 사용 중인데, rm 명령어로 인해 파일의 '이름표'는 사라졌다. 하지만 프로세스는 여전히 그 파일의 '알맹이(Inode)'를 붙잡고 있는 상황.
- /proc의 역할: 
  - /proc 디렉토리 안에는 실행 중인 각 프로세스의 정보가 자신의 PID를 이름으로 하는 하위 디렉토리에 저장됨. 예를 들어 PID가 470인 프로세스의 정보는 /proc/470/ 안에 있다.
  - 특히 /proc/470/fd/ 디렉토리 안에는 해당 프로세스가 열고 있는 모든 파일들의 목록이 파일 디스크립터(FD) 번호를 이름으로 하여 링크처럼 존재하고 있음.
- 해결의 실마리: 
  - 즉, /data/bin/m2ms/log/m2ms_20241202.log 라는 원래의 이름표는 사라졌지만, /proc/470/fd/3 이라는 커널과 직접 통하는 또 다른 이름표는 아직 남아있는 것.
- truncate 실행: 우리가 아래 명령어를 실행하면,
```sh
sudo truncate -s 0 /proc/[PID]/fd/[fd번호]
```
  - /proc/470/fd/3 이라는 링크 자체를 변경하는 것이 아니라, 이 링크가 가리키는 파일의 실제 '알맹이(Inode)'의 내용을 0으로 만들라는 명령을 커널에 직접 전달하는 것과 같습니다.

결론적으로, 이 방법은 커널이 제공하는 일종의 '비상 통로'를 이용해, 프로세스를 건드리지 않고 프로세스가 붙잡고 있는 파일의 내용물만 정확히 비워서 디스크 공간을 회수하는 매우 효과적인 기법입니다.